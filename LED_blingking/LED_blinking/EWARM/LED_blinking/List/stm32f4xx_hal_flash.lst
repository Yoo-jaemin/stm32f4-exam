###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         19/Jun/2024  10:36:56
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash.c
#    Command line =  
#        -f C:\Users\JASAN1~1\AppData\Local\Temp\EW2DE.tmp
#        (D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\List
#        -lA
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\List
#        -o
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.2\arm\inc\c\DLib_Config_Full.h"
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\STM32F4xx_HAL_Driver\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\CMSIS\Include\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/../Core/Inc\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -Ol)
#    Locale       =  C
#    List file    =  
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\List\stm32f4xx_hal_flash.lst
#    Object file  =  
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\Obj\stm32f4xx_hal_flash.o
#
###############################################################################

D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions 
     10            *           + Peripheral Errors functions
     11            *         
     12            @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16                     
     17            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     18                 to the Flash memory. It implements the erase and program Flash memory operations 
     19                 and the read and write protection mechanisms.
     20                
     21            [..] The Flash memory interface accelerates code execution with a system of instruction
     22                 prefetch and cache lines. 
     23          
     24            [..] The FLASH main features are:
     25                (+) Flash memory read operations
     26                (+) Flash memory program/erase operations
     27                (+) Read / write protections
     28                (+) Prefetch on I-Code
     29                (+) 64 cache lines of 128 bits on I-Code
     30                (+) 8 cache lines of 128 bits on D-Code
     31                
     32                
     33                               ##### How to use this driver #####
     34            ==============================================================================
     35              [..]                             
     36                This driver provides functions and macros to configure and program the FLASH 
     37                memory of all STM32F4xx devices.
     38              
     39                (#) FLASH Memory IO Programming functions: 
     40                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
     41                          HAL_FLASH_Lock() functions
     42                     (++) Program functions: byte, half word, word and double word
     43                     (++) There Two modes of programming :
     44                      (+++) Polling mode using HAL_FLASH_Program() function
     45                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     46              
     47                (#) Interrupts and flags management functions : 
     48                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     49                     (++) Wait for last FLASH operation according to its status
     50                     (++) Get error flag status by calling HAL_SetErrorCode()          
     51          
     52              [..] 
     53                In addition to these functions, this driver includes a set of macros allowing
     54                to handle the following operations:
     55                 (+) Set the latency
     56                 (+) Enable/Disable the prefetch buffer
     57                 (+) Enable/Disable the Instruction cache and the Data cache
     58                 (+) Reset the Instruction cache and the Data cache
     59                 (+) Enable/Disable the FLASH interrupts
     60                 (+) Monitor the FLASH flags status
     61                    
     62            @endverbatim
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * Copyright (c) 2017 STMicroelectronics.
     67            * All rights reserved.
     68            *
     69            * This software is licensed under terms that can be found in the LICENSE file in
     70            * the root directory of this software component.
     71            * If no LICENSE file comes with this software, it is provided AS-IS.
     72            ******************************************************************************
     73            */ 
     74          
     75          /* Includes ------------------------------------------------------------------*/
     76          #include "stm32f4xx_hal.h"
     77          
     78          /** @addtogroup STM32F4xx_HAL_Driver
     79            * @{
     80            */
     81          
     82          /** @defgroup FLASH FLASH
     83            * @brief FLASH HAL module driver
     84            * @{
     85            */
     86          
     87          #ifdef HAL_FLASH_MODULE_ENABLED
     88          
     89          /* Private typedef -----------------------------------------------------------*/
     90          /* Private define ------------------------------------------------------------*/
     91          /** @addtogroup FLASH_Private_Constants
     92            * @{
     93            */
     94          #define FLASH_TIMEOUT_VALUE       50000U /* 50 s */
     95          /**
     96            * @}
     97            */         
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          /** @addtogroup FLASH_Private_Variables
    101            * @{
    102            */
    103          /* Variable used for Erase sectors under interruption */

   \                                 In section .bss, align 4
    104          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \        0x0                      DS8 32
    105          /**
    106            * @}
    107            */
    108          
    109          /* Private function prototypes -----------------------------------------------*/
    110          /** @addtogroup FLASH_Private_Functions
    111            * @{
    112            */
    113          /* Program operations */
    114          static void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);
    115          static void   FLASH_Program_Word(uint32_t Address, uint32_t Data);
    116          static void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    117          static void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);
    118          static void   FLASH_SetErrorCode(void);
    119          
    120          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
    121          /**
    122            * @}
    123            */
    124          
    125          /* Exported functions --------------------------------------------------------*/
    126          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    127            * @{
    128            */
    129            
    130          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    131           *  @brief   Programming operation functions 
    132           *
    133          @verbatim   
    134           ===============================================================================
    135                            ##### Programming operation functions #####
    136           ===============================================================================  
    137              [..]
    138              This subsection provides a set of functions allowing to manage the FLASH 
    139              program operations.
    140          
    141          @endverbatim
    142            * @{
    143            */
    144          
    145          /**
    146            * @brief  Program byte, halfword, word or double word at a specified address
    147            * @param  TypeProgram  Indicate the way to program at a specified address.
    148            *                           This parameter can be a value of @ref FLASH_Type_Program
    149            * @param  Address  specifies the address to be programmed.
    150            * @param  Data specifies the data to be programmed
    151            * 
    152            * @retval HAL_StatusTypeDef HAL Status
    153            */

   \                                 In section .text, align 2, keep-with-next
    154          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    155          {
   \                     HAL_FLASH_Program: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
    156            HAL_StatusTypeDef status = HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
    157            
    158            /* Process Locked */
    159            __HAL_LOCK(&pFlash);
   \        0xE   0x....'....        LDR.W    R7,??DataTable14
   \       0x12   0x7E38             LDRB     R0,[R7, #+24]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD101             BNE.N    ??HAL_FLASH_Program_0
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xE02F             B.N      ??HAL_FLASH_Program_1
   \                     ??HAL_FLASH_Program_0: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x7638             STRB     R0,[R7, #+24]
    160            
    161            /* Check the parameters */
    162            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    163            
    164            /* Wait for last operation to be completed */
    165            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \       0x20   0xF24C 0x3850      MOVW     R8,#+50000
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x....'....        BL       FLASH_WaitForLastOperation
    166            
    167            if(status == HAL_OK)
   \       0x2A   0x0001             MOVS     R1,R0
   \       0x2C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD121             BNE.N    ??HAL_FLASH_Program_2
   \       0x32   0x4649             MOV      R1,R9
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x0022             MOVS     R2,R4
   \       0x38   0x002B             MOVS     R3,R5
    168            {
    169              if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
   \       0x3A   0x2900             CMP      R1,#+0
   \       0x3C   0xD104             BNE.N    ??HAL_FLASH_Program_3
    170              {
    171                /*Program byte (8-bit) at a specified address.*/
    172                FLASH_Program_Byte(Address, (uint8_t) Data);
   \       0x3E   0x0011             MOVS     R1,R2
   \       0x40   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x42   0x....'....        BL       FLASH_Program_Byte
   \       0x46   0xE00E             B.N      ??HAL_FLASH_Program_4
    173              }
    174              else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
   \                     ??HAL_FLASH_Program_3: (+1)
   \       0x48   0x2901             CMP      R1,#+1
   \       0x4A   0xD104             BNE.N    ??HAL_FLASH_Program_5
    175              {
    176                /*Program halfword (16-bit) at a specified address.*/
    177                FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \       0x4C   0x0011             MOVS     R1,R2
   \       0x4E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x50   0x....'....        BL       FLASH_Program_HalfWord
   \       0x54   0xE007             B.N      ??HAL_FLASH_Program_4
    178              }
    179              else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \                     ??HAL_FLASH_Program_5: (+1)
   \       0x56   0x2902             CMP      R1,#+2
   \       0x58   0xD103             BNE.N    ??HAL_FLASH_Program_6
    180              {
    181                /*Program word (32-bit) at a specified address.*/
    182                FLASH_Program_Word(Address, (uint32_t) Data);
   \       0x5A   0x0011             MOVS     R1,R2
   \       0x5C   0x....'....        BL       FLASH_Program_Word
   \       0x60   0xE001             B.N      ??HAL_FLASH_Program_4
    183              }
    184              else
    185              {
    186                /*Program double word (64-bit) at a specified address.*/
    187                FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_6: (+1)
   \       0x62   0x....'....        BL       FLASH_Program_DoubleWord
    188              }
    189              
    190              /* Wait for last operation to be completed */
    191              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASH_Program_4: (+1)
   \       0x66   0x4640             MOV      R0,R8
   \       0x68   0x....'....        BL       FLASH_WaitForLastOperation
    192              
    193              /* If the program operation is completed, disable the PG Bit */
    194              FLASH->CR &= (~FLASH_CR_PG);  
   \       0x6C   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \       0x6E   0x680A             LDR      R2,[R1, #+0]
   \       0x70   0x0852             LSRS     R2,R2,#+1
   \       0x72   0x0052             LSLS     R2,R2,#+1
   \       0x74   0x600A             STR      R2,[R1, #+0]
    195            }
    196            
    197            /* Process Unlocked */
    198            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2: (+1)
   \       0x76   0x2100             MOVS     R1,#+0
   \       0x78   0x7639             STRB     R1,[R7, #+24]
    199            
    200            return status;
   \       0x7A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_1: (+1)
   \       0x7C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    201          }
    202          
    203          /**
    204            * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
    205            * @param  TypeProgram  Indicate the way to program at a specified address.
    206            *                           This parameter can be a value of @ref FLASH_Type_Program
    207            * @param  Address  specifies the address to be programmed.
    208            * @param  Data specifies the data to be programmed
    209            * 
    210            * @retval HAL Status
    211            */

   \                                 In section .text, align 2, keep-with-next
    212          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    213          {
   \                     HAL_FLASH_Program_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0008             MOVS     R0,R1
    214            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
    215            
    216            /* Process Locked */
    217            __HAL_LOCK(&pFlash);
   \        0x8   0x....             LDR.N    R1,??DataTable14
   \        0xA   0x7E0E             LDRB     R6,[R1, #+24]
   \        0xC   0x2E01             CMP      R6,#+1
   \        0xE   0xD101             BNE.N    ??HAL_FLASH_Program_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE025             B.N      ??HAL_FLASH_Program_IT_1
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \       0x14   0x2601             MOVS     R6,#+1
   \       0x16   0x760E             STRB     R6,[R1, #+24]
    218          
    219            /* Check the parameters */
    220            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    221          
    222            /* Enable End of FLASH Operation interrupt */
    223            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
   \       0x18   0x....             LDR.N    R6,??DataTable14_1  ;; 0x40023c10
   \       0x1A   0x6837             LDR      R7,[R6, #+0]
   \       0x1C   0xF057 0x7780      ORRS     R7,R7,#0x1000000
   \       0x20   0x6037             STR      R7,[R6, #+0]
    224            
    225            /* Enable Error source interrupt */
    226            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
   \       0x22   0x6837             LDR      R7,[R6, #+0]
   \       0x24   0xF057 0x7700      ORRS     R7,R7,#0x2000000
   \       0x28   0x6037             STR      R7,[R6, #+0]
    227          
    228            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \       0x2A   0x2603             MOVS     R6,#+3
   \       0x2C   0x700E             STRB     R6,[R1, #+0]
    229            pFlash.Address = Address;
   \       0x2E   0x6148             STR      R0,[R1, #+20]
    230          
    231            if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD104             BNE.N    ??HAL_FLASH_Program_IT_2
    232            {
    233              /*Program byte (8-bit) at a specified address.*/
    234                FLASH_Program_Byte(Address, (uint8_t) Data);
   \       0x34   0x0011             MOVS     R1,R2
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0x....'....        BL       FLASH_Program_Byte
   \       0x3C   0xE00E             B.N      ??HAL_FLASH_Program_IT_3
    235            }
    236            else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \       0x3E   0x2C01             CMP      R4,#+1
   \       0x40   0xD104             BNE.N    ??HAL_FLASH_Program_IT_4
    237            {
    238              /*Program halfword (16-bit) at a specified address.*/
    239              FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \       0x42   0x0011             MOVS     R1,R2
   \       0x44   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x46   0x....'....        BL       FLASH_Program_HalfWord
   \       0x4A   0xE007             B.N      ??HAL_FLASH_Program_IT_3
    240            }
    241            else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \       0x4C   0x2C02             CMP      R4,#+2
   \       0x4E   0xD103             BNE.N    ??HAL_FLASH_Program_IT_5
    242            {
    243              /*Program word (32-bit) at a specified address.*/
    244              FLASH_Program_Word(Address, (uint32_t) Data);
   \       0x50   0x0011             MOVS     R1,R2
   \       0x52   0x....'....        BL       FLASH_Program_Word
   \       0x56   0xE001             B.N      ??HAL_FLASH_Program_IT_3
    245            }
    246            else
    247            {
    248              /*Program double word (64-bit) at a specified address.*/
    249              FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_IT_5: (+1)
   \       0x58   0x....'....        BL       FLASH_Program_DoubleWord
    250            }
    251          
    252            return status;
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \       0x60   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    253          }
    254          
    255          /**
    256            * @brief This function handles FLASH interrupt request.
    257            * @retval None
    258            */

   \                                 In section .text, align 2, keep-with-next
    259          void HAL_FLASH_IRQHandler(void)
    260          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    261            uint32_t addresstmp = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
    262            
    263            /* Check FLASH operation error flags */
    264          #if defined(FLASH_SR_RDERR) 
    265            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    266              FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR | FLASH_FLAG_RDERR)) != RESET)
    267          #else
    268            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    269              FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
   \        0x4   0x....             LDR.N    R4,??DataTable14_2  ;; 0x40023c0c
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0xF010 0x0FF2      TST      R0,#0xF2
   \        0xC   0xD015             BEQ.N    ??HAL_FLASH_IRQHandler_0
    270          #endif /* FLASH_SR_RDERR */
    271            {
    272              if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
   \        0xE   0x....             LDR.N    R6,??DataTable14
   \       0x10   0x7830             LDRB     R0,[R6, #+0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD104             BNE.N    ??HAL_FLASH_IRQHandler_1
    273              {
    274                /*return the faulty sector*/
    275                addresstmp = pFlash.Sector;
   \       0x16   0x68F5             LDR      R5,[R6, #+12]
    276                pFlash.Sector = 0xFFFFFFFFU;
   \       0x18   0xF05F 0x30FF      MOVS     R0,#-1
   \       0x1C   0x60F0             STR      R0,[R6, #+12]
   \       0x1E   0xE005             B.N      ??HAL_FLASH_IRQHandler_2
    277              }
    278              else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \       0x20   0x7830             LDRB     R0,[R6, #+0]
   \       0x22   0x2802             CMP      R0,#+2
   \       0x24   0xD101             BNE.N    ??HAL_FLASH_IRQHandler_3
    279              {
    280                /*return the faulty bank*/
    281                addresstmp = pFlash.Bank;
   \       0x26   0x6935             LDR      R5,[R6, #+16]
   \       0x28   0xE000             B.N      ??HAL_FLASH_IRQHandler_2
    282              }
    283              else
    284              {
    285                /*return the faulty address*/
    286                addresstmp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \       0x2A   0x6975             LDR      R5,[R6, #+20]
    287              }
    288              
    289              /*Save the Error code*/
    290              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \       0x2C   0x....'....        BL       FLASH_SetErrorCode
    291              
    292              /* FLASH error interrupt user callback */
    293              HAL_FLASH_OperationErrorCallback(addresstmp);
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x....'....        BL       HAL_FLASH_OperationErrorCallback
    294              
    295              /*Stop the procedure ongoing*/
    296              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x7030             STRB     R0,[R6, #+0]
    297            }
    298            
    299            /* Check FLASH End of Operation flag  */
    300            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x07C0             LSLS     R0,R0,#+31
   \       0x3E   0xD52F             BPL.N    ??HAL_FLASH_IRQHandler_4
    301            {
    302              /* Clear FLASH End of Operation pending bit */
    303              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x6020             STR      R0,[R4, #+0]
    304              
    305              if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
   \       0x44   0x....             LDR.N    R4,??DataTable14
   \       0x46   0x7820             LDRB     R0,[R4, #+0]
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD11B             BNE.N    ??HAL_FLASH_IRQHandler_5
    306              {
    307                /*Nb of sector to erased can be decreased*/
    308                pFlash.NbSectorsToErase--;
   \       0x4C   0x6860             LDR      R0,[R4, #+4]
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0x6060             STR      R0,[R4, #+4]
    309                
    310                /* Check if there are still sectors to erase*/
    311                if(pFlash.NbSectorsToErase != 0U)
   \       0x52   0x6860             LDR      R0,[R4, #+4]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD00A             BEQ.N    ??HAL_FLASH_IRQHandler_6
    312                {
    313                  addresstmp = pFlash.Sector;
   \       0x58   0x68E0             LDR      R0,[R4, #+12]
    314                  /*Indicate user which sector has been erased*/
    315                  HAL_FLASH_EndOfOperationCallback(addresstmp);
   \       0x5A   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
    316                  
    317                  /*Increment sector number*/
    318                  pFlash.Sector++;
   \       0x5E   0x68E0             LDR      R0,[R4, #+12]
   \       0x60   0x1C40             ADDS     R0,R0,#+1
   \       0x62   0x60E0             STR      R0,[R4, #+12]
    319                  addresstmp = pFlash.Sector;
   \       0x64   0x68E0             LDR      R0,[R4, #+12]
    320                  FLASH_Erase_Sector(addresstmp, pFlash.VoltageForErase);
   \       0x66   0x7A21             LDRB     R1,[R4, #+8]
   \       0x68   0x....'....        BL       FLASH_Erase_Sector
   \       0x6C   0xE018             B.N      ??HAL_FLASH_IRQHandler_4
    321                }
    322                else
    323                {
    324                  /*No more sectors to Erase, user callback can be called.*/
    325                  /*Reset Sector and stop Erase sectors procedure*/
    326                  pFlash.Sector = addresstmp = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \       0x6E   0xF05F 0x35FF      MOVS     R5,#-1
   \       0x72   0x60E5             STR      R5,[R4, #+12]
    327                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x7020             STRB     R0,[R4, #+0]
    328                  
    329                  /* Flush the caches to be sure of the data consistency */
    330                  FLASH_FlushCaches() ;
   \       0x78   0x....'....        BL       FLASH_FlushCaches
    331                          
    332                  /* FLASH EOP interrupt user callback */
    333                  HAL_FLASH_EndOfOperationCallback(addresstmp);
   \       0x7C   0x0028             MOVS     R0,R5
   \       0x7E   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
   \       0x82   0xE00D             B.N      ??HAL_FLASH_IRQHandler_4
    334                }
    335              }
    336              else 
    337              {
    338                if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE) 
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \       0x84   0x7820             LDRB     R0,[R4, #+0]
   \       0x86   0x2802             CMP      R0,#+2
   \       0x88   0xD105             BNE.N    ??HAL_FLASH_IRQHandler_7
    339                {
    340                  /* MassErase ended. Return the selected bank */
    341                  /* Flush the caches to be sure of the data consistency */
    342                  FLASH_FlushCaches() ;
   \       0x8A   0x....'....        BL       FLASH_FlushCaches
    343          
    344                  /* FLASH EOP interrupt user callback */
    345                  HAL_FLASH_EndOfOperationCallback(pFlash.Bank);
   \       0x8E   0x6920             LDR      R0,[R4, #+16]
   \       0x90   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
   \       0x94   0xE002             B.N      ??HAL_FLASH_IRQHandler_8
    346                }
    347                else
    348                {
    349                  /*Program ended. Return the selected address*/
    350                  /* FLASH EOP interrupt user callback */
    351                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \       0x96   0x6960             LDR      R0,[R4, #+20]
   \       0x98   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
    352                }
    353                pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0x7020             STRB     R0,[R4, #+0]
    354              }
    355            }
    356            
    357            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \       0xA0   0x....             LDR.N    R1,??DataTable14
   \       0xA2   0x7808             LDRB     R0,[R1, #+0]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD10E             BNE.N    ??HAL_FLASH_IRQHandler_9
    358            {
    359              /* Operation is completed, disable the PG, SER, SNB and MER Bits */
    360              CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_SER | FLASH_CR_SNB | FLASH_MER_BIT));
   \       0xA8   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40023c10
   \       0xAA   0x6802             LDR      R2,[R0, #+0]
   \       0xAC   0x0A12             LSRS     R2,R2,#+8
   \       0xAE   0x0212             LSLS     R2,R2,#+8
   \       0xB0   0x6002             STR      R2,[R0, #+0]
    361          
    362              /* Disable End of FLASH Operation interrupt */
    363              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
   \       0xB2   0x6802             LDR      R2,[R0, #+0]
   \       0xB4   0xF032 0x7280      BICS     R2,R2,#0x1000000
   \       0xB8   0x6002             STR      R2,[R0, #+0]
    364              
    365              /* Disable Error source interrupt */
    366              __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
   \       0xBA   0x6802             LDR      R2,[R0, #+0]
   \       0xBC   0xF032 0x7200      BICS     R2,R2,#0x2000000
   \       0xC0   0x6002             STR      R2,[R0, #+0]
    367              
    368              /* Process Unlocked */
    369              __HAL_UNLOCK(&pFlash);
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x7608             STRB     R0,[R1, #+24]
    370            }
    371          }
   \                     ??HAL_FLASH_IRQHandler_9: (+1)
   \       0xC6   0xBD70             POP      {R4-R6,PC}       ;; return
    372          
    373          /**
    374            * @brief  FLASH end of operation interrupt callback
    375            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    376            *                  Mass Erase: Bank number which has been requested to erase
    377            *                  Sectors Erase: Sector which has been erased 
    378            *                    (if 0xFFFFFFFFU, it means that all the selected sectors have been erased)
    379            *                  Program: Address which was selected for data program
    380            * @retval None
    381            */

   \                                 In section .text, align 2
    382          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    383          {
    384            /* Prevent unused argument(s) compilation warning */
    385            UNUSED(ReturnValue);
    386            /* NOTE : This function Should not be modified, when the callback is needed,
    387                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    388             */ 
    389          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    390          
    391          /**
    392            * @brief  FLASH operation error interrupt callback
    393            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    394            *                 Mass Erase: Bank number which has been requested to erase
    395            *                 Sectors Erase: Sector number which returned an error
    396            *                 Program: Address which was selected for data program
    397            * @retval None
    398            */

   \                                 In section .text, align 2
    399          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    400          {
    401            /* Prevent unused argument(s) compilation warning */
    402            UNUSED(ReturnValue);
    403            /* NOTE : This function Should not be modified, when the callback is needed,
    404                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    405             */ 
    406          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    407          
    408          /**
    409            * @}
    410            */
    411          
    412          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    413           *  @brief   management functions 
    414           *
    415          @verbatim   
    416           ===============================================================================
    417                                ##### Peripheral Control functions #####
    418           ===============================================================================  
    419              [..]
    420              This subsection provides a set of functions allowing to control the FLASH 
    421              memory operations.
    422          
    423          @endverbatim
    424            * @{
    425            */
    426          
    427          /**
    428            * @brief  Unlock the FLASH control register access
    429            * @retval HAL Status
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    432          {
    433            HAL_StatusTypeDef status = HAL_OK;
   \                     HAL_FLASH_Unlock: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
    434          
    435            if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
   \        0x2   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD508             BPL.N    ??HAL_FLASH_Unlock_0
    436            {
    437              /* Authorize the FLASH Registers access */
    438              WRITE_REG(FLASH->KEYR, FLASH_KEY1);
   \        0xA   0x....             LDR.N    R2,??DataTable14_3  ;; 0x40023c04
   \        0xC   0x....             LDR.N    R3,??DataTable14_4  ;; 0x45670123
   \        0xE   0x6013             STR      R3,[R2, #+0]
    439              WRITE_REG(FLASH->KEYR, FLASH_KEY2);
   \       0x10   0x....             LDR.N    R3,??DataTable14_5  ;; 0xcdef89ab
   \       0x12   0x6013             STR      R3,[R2, #+0]
    440          
    441              /* Verify Flash is unlocked */
    442              if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD500             BPL.N    ??HAL_FLASH_Unlock_0
    443              {
    444                status = HAL_ERROR;
   \       0x1A   0x2001             MOVS     R0,#+1
    445              }
    446            }
    447          
    448            return status;
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \       0x1C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1E   0x4770             BX       LR               ;; return
    449          }
    450          
    451          /**
    452            * @brief  Locks the FLASH control register access
    453            * @retval HAL Status
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    456          {
    457            /* Set the LOCK Bit to lock the FLASH Registers access */
    458            FLASH->CR |= FLASH_CR_LOCK;
   \                     HAL_FLASH_Lock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40023c10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x4100      ORRS     R1,R1,#0x80000000
   \        0x8   0x6001             STR      R1,[R0, #+0]
    459            
    460            return HAL_OK;  
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR               ;; return
    461          }
    462          
    463          /**
    464            * @brief  Unlock the FLASH Option Control Registers access.
    465            * @retval HAL Status
    466            */

   \                                 In section .text, align 2, keep-with-next
    467          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    468          {
    469            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     HAL_FLASH_OB_Unlock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable14_6  ;; 0x40023c14
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x07C0             LSLS     R0,R0,#+31
   \        0x6   0xD506             BPL.N    ??HAL_FLASH_OB_Unlock_0
    470            {
    471              /* Authorizes the Option Byte register programming */
    472              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \        0x8   0x....             LDR.N    R0,??DataTable14_7  ;; 0x40023c08
   \        0xA   0x....             LDR.N    R1,??DataTable14_8  ;; 0x8192a3b
   \        0xC   0x6001             STR      R1,[R0, #+0]
    473              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \        0xE   0x....             LDR.N    R1,??DataTable14_9  ;; 0x4c5d6e7f
   \       0x10   0x6001             STR      R1,[R0, #+0]
    474            }
    475            else
    476            {
    477              return HAL_ERROR;
    478            }  
    479            
    480            return HAL_OK;  
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE000             B.N      ??HAL_FLASH_OB_Unlock_1
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_OB_Unlock_1: (+1)
   \       0x18   0x4770             BX       LR               ;; return
    481          }
    482          
    483          /**
    484            * @brief  Lock the FLASH Option Control Registers access.
    485            * @retval HAL Status 
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    488          {
    489            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    490            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     HAL_FLASH_OB_Lock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable14_6  ;; 0x40023c14
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    491            
    492            return HAL_OK;  
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR               ;; return
    493          }
    494          
    495          /**
    496            * @brief  Launch the option byte loading.
    497            * @retval HAL Status
    498            */

   \                                 In section .text, align 2, keep-with-next
    499          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    500          {
   \                     HAL_FLASH_OB_Launch: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    501            /* Set the OPTSTRT bit in OPTCR register */
    502            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \        0x2   0x....             LDR.N    R0,??DataTable14_6  ;; 0x40023c14
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0xF051 0x0102      ORRS     R1,R1,#0x2
   \        0xA   0x7001             STRB     R1,[R0, #+0]
    503          
    504            /* Wait for last operation to be completed */
    505            return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); 
   \        0xC   0xF24C 0x3050      MOVW     R0,#+50000
   \       0x10   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
    506          }
    507          
    508          /**
    509            * @}
    510            */
    511          
    512          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
    513           *  @brief   Peripheral Errors functions 
    514           *
    515          @verbatim   
    516           ===============================================================================
    517                          ##### Peripheral Errors functions #####
    518           ===============================================================================  
    519              [..]
    520              This subsection permits to get in run-time Errors of the FLASH peripheral.
    521          
    522          @endverbatim
    523            * @{
    524            */
    525          
    526          /**
    527            * @brief  Get the specific FLASH error flag.
    528            * @retval FLASH_ErrorCode: The returned value can be a combination of:
    529            *            @arg HAL_FLASH_ERROR_RD: FLASH Read Protection error flag (PCROP)
    530            *            @arg HAL_FLASH_ERROR_PGS: FLASH Programming Sequence error flag 
    531            *            @arg HAL_FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
    532            *            @arg HAL_FLASH_ERROR_PGA: FLASH Programming Alignment error flag
    533            *            @arg HAL_FLASH_ERROR_WRP: FLASH Write protected error flag
    534            *            @arg HAL_FLASH_ERROR_OPERATION: FLASH operation Error flag 
    535            */

   \                                 In section .text, align 2, keep-with-next
    536          uint32_t HAL_FLASH_GetError(void)
    537          { 
    538             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable14
   \        0x2   0x69C0             LDR      R0,[R0, #+28]
   \        0x4   0x4770             BX       LR               ;; return
    539          }  
    540            
    541          /**
    542            * @}
    543            */    
    544          
    545          /**
    546            * @brief  Wait for a FLASH operation to complete.
    547            * @param  Timeout maximum flash operationtimeout
    548            * @retval HAL Status
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    551          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    552            uint32_t tickstart = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
    553            
    554            /* Clear Error Code */
    555            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....             LDR.N    R1,??DataTable14
   \        0xA   0x61C8             STR      R0,[R1, #+28]
    556            
    557            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    558               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    559               flag will be set */
    560            /* Get tick */
    561            tickstart = HAL_GetTick();
   \        0xC   0x....'....        BL       HAL_GetTick
   \       0x10   0x0005             MOVS     R5,R0
    562          
    563            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x03C9             LSLS     R1,R1,#+15
   \       0x18   0xD50B             BPL.N    ??FLASH_WaitForLastOperation_1
    564            { 
    565              if(Timeout != HAL_MAX_DELAY)
   \       0x1A   0xF114 0x0F01      CMN      R4,#+1
   \       0x1E   0xD0F8             BEQ.N    ??FLASH_WaitForLastOperation_0
    566              {
    567                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD004             BEQ.N    ??FLASH_WaitForLastOperation_2
   \       0x24   0x....'....        BL       HAL_GetTick
   \       0x28   0x1B40             SUBS     R0,R0,R5
   \       0x2A   0x4284             CMP      R4,R0
   \       0x2C   0xD2F1             BCS.N    ??FLASH_WaitForLastOperation_0
    568                {
    569                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \       0x2E   0x2003             MOVS     R0,#+3
   \       0x30   0xE00D             B.N      ??FLASH_WaitForLastOperation_3
    570                }
    571              } 
    572            }
    573          
    574            /* Check FLASH End of Operation flag  */
    575            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0x07C9             LSLS     R1,R1,#+31
   \       0x36   0xD501             BPL.N    ??FLASH_WaitForLastOperation_4
    576            {
    577              /* Clear FLASH End of Operation pending bit */
    578              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \       0x38   0x2101             MOVS     R1,#+1
   \       0x3A   0x6001             STR      R1,[R0, #+0]
    579            }
    580          #if defined(FLASH_SR_RDERR)  
    581            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    582                                     FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR | FLASH_FLAG_RDERR)) != RESET)
    583          #else
    584            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    585                                     FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0xF010 0x0FF2      TST      R0,#0xF2
   \       0x42   0xD003             BEQ.N    ??FLASH_WaitForLastOperation_5
    586          #endif /* FLASH_SR_RDERR */
    587            {
    588              /*Save the error code*/
    589              FLASH_SetErrorCode();
   \       0x44   0x....'....        BL       FLASH_SetErrorCode
    590              return HAL_ERROR;
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xE000             B.N      ??FLASH_WaitForLastOperation_3
    591            }
    592          
    593            /* If there is no error flag set */
    594            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_5: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \       0x4E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    595            
    596          }  
    597          
    598          /**
    599            * @brief  Program a double word (64-bit) at a specified address.
    600            * @note   This function must be used when the device voltage range is from
    601            *         2.7V to 3.6V and Vpp in the range 7V to 9V.
    602            *
    603            * @note   If an erase and a program operations are requested simultaneously,    
    604            *         the erase operation is performed before the program one.
    605            *  
    606            * @param  Address specifies the address to be programmed.
    607            * @param  Data specifies the data to be programmed.
    608            * @retval None
    609            */

   \                                 In section .text, align 2, keep-with-next
    610          static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
    611          {
   \                     FLASH_Program_DoubleWord: (+1)
   \        0x0   0xB410             PUSH     {R4}
    612            /* Check the parameters */
    613            assert_param(IS_FLASH_ADDRESS(Address));
    614            
    615            /* If the previous operation is completed, proceed to program the new data */
    616            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \        0x2   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \        0x4   0x680C             LDR      R4,[R1, #+0]
   \        0x6   0xF434 0x7440      BICS     R4,R4,#0x300
   \        0xA   0x600C             STR      R4,[R1, #+0]
    617            FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \        0xC   0x680C             LDR      R4,[R1, #+0]
   \        0xE   0xF454 0x7440      ORRS     R4,R4,#0x300
   \       0x12   0x600C             STR      R4,[R1, #+0]
    618            FLASH->CR |= FLASH_CR_PG;
   \       0x14   0x680C             LDR      R4,[R1, #+0]
   \       0x16   0xF054 0x0401      ORRS     R4,R4,#0x1
   \       0x1A   0x600C             STR      R4,[R1, #+0]
    619          
    620            /* Program first word */
    621            *(__IO uint32_t*)Address = (uint32_t)Data;
   \       0x1C   0x6002             STR      R2,[R0, #+0]
    622          
    623            /* Barrier to ensure programming is performed in 2 steps, in right order
    624              (independently of compiler optimization behavior) */
    625            __ISB();
   \       0x1E   0xF3BF 0x8F6F      ISB      SY
    626          
    627            /* Program second word */
    628            *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
   \       0x22   0x1D00             ADDS     R0,R0,#+4
   \       0x24   0x6003             STR      R3,[R0, #+0]
    629          }
   \       0x26   0xBC10             POP      {R4}
   \       0x28   0x4770             BX       LR               ;; return
    630          
    631          
    632          /**
    633            * @brief  Program word (32-bit) at a specified address.
    634            * @note   This function must be used when the device voltage range is from
    635            *         2.7V to 3.6V.
    636            *
    637            * @note   If an erase and a program operations are requested simultaneously,    
    638            *         the erase operation is performed before the program one.
    639            *  
    640            * @param  Address specifies the address to be programmed.
    641            * @param  Data specifies the data to be programmed.
    642            * @retval None
    643            */

   \                                 In section .text, align 2, keep-with-next
    644          static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
    645          {
    646            /* Check the parameters */
    647            assert_param(IS_FLASH_ADDRESS(Address));
    648            
    649            /* If the previous operation is completed, proceed to program the new data */
    650            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \                     FLASH_Program_Word: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0xF433 0x7340      BICS     R3,R3,#0x300
   \        0x8   0x6013             STR      R3,[R2, #+0]
    651            FLASH->CR |= FLASH_PSIZE_WORD;
   \        0xA   0x6813             LDR      R3,[R2, #+0]
   \        0xC   0xF453 0x7300      ORRS     R3,R3,#0x200
   \       0x10   0x6013             STR      R3,[R2, #+0]
    652            FLASH->CR |= FLASH_CR_PG;
   \       0x12   0x6813             LDR      R3,[R2, #+0]
   \       0x14   0xF053 0x0301      ORRS     R3,R3,#0x1
   \       0x18   0x6013             STR      R3,[R2, #+0]
    653          
    654            *(__IO uint32_t*)Address = Data;
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    655          }
   \       0x1C   0x4770             BX       LR               ;; return
    656          
    657          /**
    658            * @brief  Program a half-word (16-bit) at a specified address.
    659            * @note   This function must be used when the device voltage range is from
    660            *         2.1V to 3.6V.
    661            *
    662            * @note   If an erase and a program operations are requested simultaneously,    
    663            *         the erase operation is performed before the program one.
    664            *  
    665            * @param  Address specifies the address to be programmed.
    666            * @param  Data specifies the data to be programmed.
    667            * @retval None
    668            */

   \                                 In section .text, align 2, keep-with-next
    669          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    670          {
    671            /* Check the parameters */
    672            assert_param(IS_FLASH_ADDRESS(Address));
    673            
    674            /* If the previous operation is completed, proceed to program the new data */
    675            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \                     FLASH_Program_HalfWord: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0xF433 0x7340      BICS     R3,R3,#0x300
   \        0x8   0x6013             STR      R3,[R2, #+0]
    676            FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \        0xA   0x6813             LDR      R3,[R2, #+0]
   \        0xC   0xF453 0x7380      ORRS     R3,R3,#0x100
   \       0x10   0x6013             STR      R3,[R2, #+0]
    677            FLASH->CR |= FLASH_CR_PG;
   \       0x12   0x6813             LDR      R3,[R2, #+0]
   \       0x14   0xF053 0x0301      ORRS     R3,R3,#0x1
   \       0x18   0x6013             STR      R3,[R2, #+0]
    678          
    679            *(__IO uint16_t*)Address = Data;
   \       0x1A   0x8001             STRH     R1,[R0, #+0]
    680          }
   \       0x1C   0x4770             BX       LR               ;; return
    681          
    682          /**
    683            * @brief  Program byte (8-bit) at a specified address.
    684            * @note   This function must be used when the device voltage range is from
    685            *         1.8V to 3.6V.
    686            *
    687            * @note   If an erase and a program operations are requested simultaneously,    
    688            *         the erase operation is performed before the program one.
    689            *  
    690            * @param  Address specifies the address to be programmed.
    691            * @param  Data specifies the data to be programmed.
    692            * @retval None
    693            */

   \                                 In section .text, align 2, keep-with-next
    694          static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
    695          {
    696            /* Check the parameters */
    697            assert_param(IS_FLASH_ADDRESS(Address));
    698            
    699            /* If the previous operation is completed, proceed to program the new data */
    700            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \                     FLASH_Program_Byte: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0xF433 0x7340      BICS     R3,R3,#0x300
   \        0x8   0x6013             STR      R3,[R2, #+0]
    701            FLASH->CR |= FLASH_PSIZE_BYTE;
   \        0xA   0x6813             LDR      R3,[R2, #+0]
   \        0xC   0x6013             STR      R3,[R2, #+0]
    702            FLASH->CR |= FLASH_CR_PG;
   \        0xE   0x6813             LDR      R3,[R2, #+0]
   \       0x10   0xF053 0x0301      ORRS     R3,R3,#0x1
   \       0x14   0x6013             STR      R3,[R2, #+0]
    703          
    704            *(__IO uint8_t*)Address = Data;
   \       0x16   0x7001             STRB     R1,[R0, #+0]
    705          }
   \       0x18   0x4770             BX       LR               ;; return
    706          
    707          /**
    708            * @brief  Set the specific FLASH error flag.
    709            * @retval None
    710            */

   \                                 In section .text, align 2, keep-with-next
    711          static void FLASH_SetErrorCode(void)
    712          { 
    713            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
   \                     FLASH_SetErrorCode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x06C9             LSLS     R1,R1,#+27
   \        0x6   0xD506             BPL.N    ??FLASH_SetErrorCode_0
    714            {
    715             pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \        0x8   0x....             LDR.N    R1,??DataTable14
   \        0xA   0x69CA             LDR      R2,[R1, #+28]
   \        0xC   0xF052 0x0210      ORRS     R2,R2,#0x10
   \       0x10   0x61CA             STR      R2,[R1, #+28]
    716             
    717             /* Clear FLASH write protection error pending bit */
    718             __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
   \       0x12   0x2110             MOVS     R1,#+16
   \       0x14   0x6001             STR      R1,[R0, #+0]
    719            }
    720            
    721            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
   \                     ??FLASH_SetErrorCode_0: (+1)
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x0689             LSLS     R1,R1,#+26
   \       0x1A   0xD506             BPL.N    ??FLASH_SetErrorCode_1
    722            {
    723             pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \       0x1C   0x....             LDR.N    R1,??DataTable14
   \       0x1E   0x69CA             LDR      R2,[R1, #+28]
   \       0x20   0xF052 0x0208      ORRS     R2,R2,#0x8
   \       0x24   0x61CA             STR      R2,[R1, #+28]
    724             
    725             /* Clear FLASH Programming alignment error pending bit */
    726             __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
   \       0x26   0x2120             MOVS     R1,#+32
   \       0x28   0x6001             STR      R1,[R0, #+0]
    727            }
    728            
    729            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
   \                     ??FLASH_SetErrorCode_1: (+1)
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x0649             LSLS     R1,R1,#+25
   \       0x2E   0xD506             BPL.N    ??FLASH_SetErrorCode_2
    730            {
    731              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
   \       0x30   0x....             LDR.N    R1,??DataTable14
   \       0x32   0x69CA             LDR      R2,[R1, #+28]
   \       0x34   0xF052 0x0204      ORRS     R2,R2,#0x4
   \       0x38   0x61CA             STR      R2,[R1, #+28]
    732              
    733              /* Clear FLASH Programming parallelism error pending bit */
    734              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
   \       0x3A   0x2140             MOVS     R1,#+64
   \       0x3C   0x6001             STR      R1,[R0, #+0]
    735            }
    736            
    737            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
   \                     ??FLASH_SetErrorCode_2: (+1)
   \       0x3E   0x6801             LDR      R1,[R0, #+0]
   \       0x40   0x0609             LSLS     R1,R1,#+24
   \       0x42   0xD506             BPL.N    ??FLASH_SetErrorCode_3
    738            {
    739              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
   \       0x44   0x....             LDR.N    R1,??DataTable14
   \       0x46   0x69CA             LDR      R2,[R1, #+28]
   \       0x48   0xF052 0x0202      ORRS     R2,R2,#0x2
   \       0x4C   0x61CA             STR      R2,[R1, #+28]
    740              
    741              /* Clear FLASH Programming sequence error pending bit */
    742              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
   \       0x4E   0x2180             MOVS     R1,#+128
   \       0x50   0x6001             STR      R1,[R0, #+0]
    743            }
    744          #if defined(FLASH_SR_RDERR) 
    745            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
    746            {
    747              pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
    748              
    749              /* Clear FLASH Proprietary readout protection error pending bit */
    750              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
    751            }
    752          #endif /* FLASH_SR_RDERR */  
    753            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
   \                     ??FLASH_SetErrorCode_3: (+1)
   \       0x52   0x6801             LDR      R1,[R0, #+0]
   \       0x54   0x0789             LSLS     R1,R1,#+30
   \       0x56   0xD506             BPL.N    ??FLASH_SetErrorCode_4
    754            {
    755              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
   \       0x58   0x....             LDR.N    R1,??DataTable14
   \       0x5A   0x69CA             LDR      R2,[R1, #+28]
   \       0x5C   0xF052 0x0220      ORRS     R2,R2,#0x20
   \       0x60   0x61CA             STR      R2,[R1, #+28]
    756              
    757              /* Clear FLASH Operation error pending bit */
    758              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
   \       0x62   0x2102             MOVS     R1,#+2
   \       0x64   0x6001             STR      R1,[R0, #+0]
    759            }
    760          }
   \                     ??FLASH_SetErrorCode_4: (+1)
   \       0x66   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x4002'3C10        DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x4002'3C0C        DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x4002'3C04        DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x4567'0123        DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0xCDEF'89AB        DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x4002'3C14        DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x4002'3C08        DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x0819'2A3B        DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x4C5D'6E7F        DC32     0x4c5d6e7f
    761          
    762          /**
    763            * @}
    764            */
    765          
    766          #endif /* HAL_FLASH_MODULE_ENABLED */
    767          
    768          /**
    769            * @}
    770            */
    771          
    772          /**
    773            * @}
    774            */
    775          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_Program_Byte
       4   FLASH_Program_DoubleWord
       0   FLASH_Program_HalfWord
       0   FLASH_Program_Word
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      16   HAL_FLASH_IRQHandler
        16   -> FLASH_Erase_Sector
        16   -> FLASH_FlushCaches
        16   -> FLASH_SetErrorCode
        16   -> HAL_FLASH_EndOfOperationCallback
        16   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       8   HAL_FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      32   HAL_FLASH_Program
        32   -> FLASH_Program_Byte
        32   -> FLASH_Program_DoubleWord
        32   -> FLASH_Program_HalfWord
        32   -> FLASH_Program_Word
        32   -> FLASH_WaitForLastOperation
      24   HAL_FLASH_Program_IT
        24   -> FLASH_Program_Byte
        24   -> FLASH_Program_DoubleWord
        24   -> FLASH_Program_HalfWord
        24   -> FLASH_Program_Word
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      26  FLASH_Program_Byte
      42  FLASH_Program_DoubleWord
      30  FLASH_Program_HalfWord
      30  FLASH_Program_Word
     104  FLASH_SetErrorCode
      80  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     200  HAL_FLASH_IRQHandler
      14  HAL_FLASH_Lock
      22  HAL_FLASH_OB_Launch
      14  HAL_FLASH_OB_Lock
      26  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     128  HAL_FLASH_Program
      98  HAL_FLASH_Program_IT
      32  HAL_FLASH_Unlock
      32  pFlash

 
  32 bytes in section .bss
 896 bytes in section .text
 
 892 bytes of CODE memory (+ 4 bytes shared)
  32 bytes of DATA memory

Errors: none
Warnings: none
