###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         19/Jun/2024  10:36:56
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
#    Command line =  
#        -f C:\Users\JASAN1~1\AppData\Local\Temp\EW439.tmp
#        (D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\List
#        -lA
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\List
#        -o
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.2\arm\inc\c\DLib_Config_Full.h"
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\STM32F4xx_HAL_Driver\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\CMSIS\Include\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/../Core/Inc\
#        -I
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -Ol)
#    Locale       =  C
#    List file    =  
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\List\stm32f4xx_hal_gpio.lst
#    Object file  =  
#        D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\EWARM\LED_blinking\Obj\stm32f4xx_hal_gpio.o
#
###############################################################################

D:\2_Projects\Exam\CubeMx\LED_blingking\LED_blinking\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * Copyright (c) 2017 STMicroelectronics.
     15            * All rights reserved.
     16            *
     17            * This software is licensed under terms that can be found in the LICENSE file
     18            * in the root directory of this software component.
     19            * If no LICENSE file comes with this software, it is provided AS-IS.
     20            *
     21            ******************************************************************************
     22            @verbatim
     23            ==============================================================================
     24                              ##### GPIO Peripheral features #####
     25            ==============================================================================
     26            [..] 
     27            Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
     28            port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
     29            in several modes:
     30            (+) Input mode 
     31            (+) Analog mode
     32            (+) Output mode
     33            (+) Alternate function mode
     34            (+) External interrupt/event lines
     35          
     36            [..]  
     37            During and just after reset, the alternate functions and external interrupt  
     38            lines are not active and the I/O ports are configured in input floating mode.
     39            
     40            [..]   
     41            All GPIO pins have weak internal pull-up and pull-down resistors, which can be 
     42            activated or not.
     43          
     44            [..]
     45            In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     46            type and the IO speed can be selected depending on the VDD value.
     47          
     48            [..]  
     49            All ports have external interrupt/event capability. To use external interrupt 
     50            lines, the port must be configured in input mode. All available GPIO pins are 
     51            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     52            
     53            [..]
     54            The external interrupt/event controller consists of up to 23 edge detectors 
     55            (16 lines are connected to GPIO) for generating event/interrupt requests (each 
     56            input line can be independently configured to select the type (interrupt or event) 
     57            and the corresponding trigger event (rising or falling or both). Each line can 
     58            also be masked independently. 
     59          
     60                               ##### How to use this driver #####
     61            ==============================================================================  
     62            [..]
     63              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). 
     64          
     65              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     66                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     67                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef 
     68                       structure.
     69                  (++) In case of Output or alternate function mode selection: the speed is 
     70                       configured through "Speed" member from GPIO_InitTypeDef structure.
     71                  (++) In alternate mode is selection, the alternate function connected to the IO
     72                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     73                  (++) Analog mode is required when a pin is to be used as ADC channel 
     74                       or DAC output.
     75                  (++) In case of external interrupt/event selection the "Mode" member from 
     76                       GPIO_InitTypeDef structure select the type (interrupt or event) and 
     77                       the corresponding trigger event (rising or falling or both).
     78          
     79              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority 
     80                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     81                  HAL_NVIC_EnableIRQ().
     82                   
     83              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     84                      
     85              (#) To set/reset the level of a pin configured in output mode use 
     86                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     87              
     88              (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     89          
     90                           
     91              (#) During and just after reset, the alternate functions are not 
     92                  active and the GPIO pins are configured in input floating mode (except JTAG
     93                  pins).
     94            
     95              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     96                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     97                  priority over the GPIO function.
     98            
     99              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
    100                  general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
    101                  The HSE has priority over the GPIO function.
    102            
    103            @endverbatim
    104            ******************************************************************************
    105            */ 
    106          
    107          /* Includes ------------------------------------------------------------------*/
    108          #include "stm32f4xx_hal.h"
    109          
    110          /** @addtogroup STM32F4xx_HAL_Driver
    111            * @{
    112            */
    113          
    114          /** @defgroup GPIO GPIO
    115            * @brief GPIO HAL module driver
    116            * @{
    117            */
    118          
    119          #ifdef HAL_GPIO_MODULE_ENABLED
    120          
    121          /* Private typedef -----------------------------------------------------------*/
    122          /* Private define ------------------------------------------------------------*/
    123          /** @addtogroup GPIO_Private_Constants GPIO Private Constants
    124            * @{
    125            */
    126          
    127          #define GPIO_NUMBER           16U
    128          /**
    129            * @}
    130            */
    131          /* Private macro -------------------------------------------------------------*/
    132          /* Private variables ---------------------------------------------------------*/
    133          /* Private function prototypes -----------------------------------------------*/
    134          /* Private functions ---------------------------------------------------------*/
    135          /* Exported functions --------------------------------------------------------*/
    136          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    137            * @{
    138            */
    139          
    140          /** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
    141            *  @brief    Initialization and Configuration functions
    142            *
    143          @verbatim    
    144           ===============================================================================
    145                        ##### Initialization and de-initialization functions #####
    146           ===============================================================================
    147            [..]
    148              This section provides functions allowing to initialize and de-initialize the GPIOs
    149              to be ready for use.
    150           
    151          @endverbatim
    152            * @{
    153            */
    154          
    155          
    156          /**
    157            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    158            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    159            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    160            * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
    161            *         the configuration information for the specified GPIO peripheral.
    162            * @retval None
    163            */

   \                                 In section .text, align 2, keep-with-next
    164          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    165          {
   \                     HAL_GPIO_Init: (+1)
   \        0x0   0xB4F8             PUSH     {R3-R7}
    166            uint32_t position;
    167            uint32_t ioposition = 0x00U;
   \        0x2   0x2200             MOVS     R2,#+0
    168            uint32_t iocurrent = 0x00U;
   \        0x4   0x2200             MOVS     R2,#+0
    169            uint32_t temp = 0x00U;
   \        0x6   0x2200             MOVS     R2,#+0
    170          
    171            /* Check the parameters */
    172            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    173            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    174            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    175          
    176            /* Configure the port pins */
    177            for(position = 0U; position < GPIO_NUMBER; position++)
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0xE037             B.N      ??HAL_GPIO_Init_0
    178            {
    179              /* Get the IO position */
    180              ioposition = 0x01U << position;
    181              /* Get the current IO position */
    182              iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
    183          
    184              if(iocurrent == ioposition)
    185              {
    186                /*--------------------- GPIO Mode Configuration ------------------------*/
    187                /* In case of Output or Alternate function mode selection */
    188                if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
    189                    (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
    190                {
    191                  /* Check the Speed parameter */
    192                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    193                  /* Configure the IO Speed */
    194                  temp = GPIOx->OSPEEDR; 
    195                  temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
    196                  temp |= (GPIO_Init->Speed << (position * 2U));
    197                  GPIOx->OSPEEDR = temp;
    198          
    199                  /* Configure the IO Output Type */
    200                  temp = GPIOx->OTYPER;
    201                  temp &= ~(GPIO_OTYPER_OT_0 << position) ;
    202                  temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
    203                  GPIOx->OTYPER = temp;
    204                 }
    205          
    206                if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
    207                {
    208                  /* Check the parameters */
    209                  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    210                  
    211                  /* Activate the Pull-up or Pull down resistor for the current IO */
    212                  temp = GPIOx->PUPDR;
    213                  temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
    214                  temp |= ((GPIO_Init->Pull) << (position * 2U));
    215                  GPIOx->PUPDR = temp;
    216                }
    217          
    218                /* In case of Alternate function mode selection */
    219                if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
    220                {
    221                  /* Check the Alternate function parameter */
    222                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    223                  /* Configure Alternate function mapped with the current IO */
    224                  temp = GPIOx->AFR[position >> 3U];
    225                  temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
    226                  temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
    227                  GPIOx->AFR[position >> 3U] = temp;
    228                }
    229          
    230                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    231                temp = GPIOx->MODER;
    232                temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
    233                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    234                GPIOx->MODER = temp;
    235          
    236                /*--------------------- EXTI Mode Configuration ------------------------*/
    237                /* Configure the External Interrupt or event for the current IO */
    238                if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
    239                {
    240                  /* Enable SYSCFG Clock */
    241                  __HAL_RCC_SYSCFG_CLK_ENABLE();
    242          
    243                  temp = SYSCFG->EXTICR[position >> 2U];
    244                  temp &= ~(0x0FU << (4U * (position & 0x03U)));
    245                  temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   \                     ??HAL_GPIO_Init_1: (+1)
   \        0xC   0x2708             MOVS     R7,#+8
   \        0xE   0xE004             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_3: (+1)
   \       0x10   0x....'....        LDR.W    R2,??DataTable2  ;; 0x40021c00
   \       0x14   0x4290             CMP      R0,R2
   \       0x16   0xD1F9             BNE.N    ??HAL_GPIO_Init_1
   \       0x18   0x2707             MOVS     R7,#+7
   \                     ??HAL_GPIO_Init_2: (+1)
   \                     ??HAL_GPIO_Init_4: (+1)
   \                     ??HAL_GPIO_Init_5: (+1)
   \                     ??HAL_GPIO_Init_6: (+1)
   \       0x1A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x1C   0xF013 0x0203      ANDS     R2,R3,#0x3
   \       0x20   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x22   0x0092             LSLS     R2,R2,#+2
   \       0x24   0x4097             LSLS     R7,R7,R2
   \       0x26   0x433E             ORRS     R6,R7,R6
    246                  SYSCFG->EXTICR[position >> 2U] = temp;
   \       0x28   0x001A             MOVS     R2,R3
   \       0x2A   0x0892             LSRS     R2,R2,#+2
   \       0x2C   0xF845 0x6022      STR      R6,[R5, R2, LSL #+2]
    247          
    248                  /* Clear Rising Falling edge configuration */
    249                  temp = EXTI->RTSR;
   \       0x30   0x....'....        LDR.W    R5,??DataTable2_1  ;; 0x40013c08
   \       0x34   0x682A             LDR      R2,[R5, #+0]
    250                  temp &= ~((uint32_t)iocurrent);
   \       0x36   0x43A2             BICS     R2,R2,R4
    251                  if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
   \       0x38   0x684E             LDR      R6,[R1, #+4]
   \       0x3A   0x02F6             LSLS     R6,R6,#+11
   \       0x3C   0xD500             BPL.N    ??HAL_GPIO_Init_7
    252                  {
    253                    temp |= iocurrent;
   \       0x3E   0x4322             ORRS     R2,R4,R2
    254                  }
    255                  EXTI->RTSR = temp;
   \                     ??HAL_GPIO_Init_7: (+1)
   \       0x40   0x602A             STR      R2,[R5, #+0]
    256          
    257                  temp = EXTI->FTSR;
   \       0x42   0x....'....        LDR.W    R5,??DataTable2_2  ;; 0x40013c0c
   \       0x46   0x682A             LDR      R2,[R5, #+0]
    258                  temp &= ~((uint32_t)iocurrent);
   \       0x48   0x43A2             BICS     R2,R2,R4
    259                  if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
   \       0x4A   0x684E             LDR      R6,[R1, #+4]
   \       0x4C   0x02B6             LSLS     R6,R6,#+10
   \       0x4E   0xD500             BPL.N    ??HAL_GPIO_Init_8
    260                  {
    261                    temp |= iocurrent;
   \       0x50   0x4322             ORRS     R2,R4,R2
    262                  }
    263                  EXTI->FTSR = temp;
   \                     ??HAL_GPIO_Init_8: (+1)
   \       0x52   0x602A             STR      R2,[R5, #+0]
    264          
    265                  temp = EXTI->EMR;
   \       0x54   0x....'....        LDR.W    R5,??DataTable2_3  ;; 0x40013c04
   \       0x58   0x682A             LDR      R2,[R5, #+0]
    266                  temp &= ~((uint32_t)iocurrent);
   \       0x5A   0x43A2             BICS     R2,R2,R4
    267                  if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
   \       0x5C   0x684E             LDR      R6,[R1, #+4]
   \       0x5E   0x03B6             LSLS     R6,R6,#+14
   \       0x60   0xD500             BPL.N    ??HAL_GPIO_Init_9
    268                  {
    269                    temp |= iocurrent;
   \       0x62   0x4322             ORRS     R2,R4,R2
    270                  }
    271                  EXTI->EMR = temp;
   \                     ??HAL_GPIO_Init_9: (+1)
   \       0x64   0x602A             STR      R2,[R5, #+0]
    272          
    273                  /* Clear EXTI line configuration */
    274                  temp = EXTI->IMR;
   \       0x66   0x....'....        LDR.W    R5,??DataTable2_4  ;; 0x40013c00
   \       0x6A   0x682A             LDR      R2,[R5, #+0]
    275                  temp &= ~((uint32_t)iocurrent);
   \       0x6C   0x43A2             BICS     R2,R2,R4
    276                  if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
   \       0x6E   0x684E             LDR      R6,[R1, #+4]
   \       0x70   0x03F6             LSLS     R6,R6,#+15
   \       0x72   0xD501             BPL.N    ??HAL_GPIO_Init_10
    277                  {
    278                    temp |= iocurrent;
   \       0x74   0x4314             ORRS     R4,R4,R2
   \       0x76   0x0022             MOVS     R2,R4
    279                  }
    280                  EXTI->IMR = temp;
   \                     ??HAL_GPIO_Init_10: (+1)
   \       0x78   0x602A             STR      R2,[R5, #+0]
   \                     ??HAL_GPIO_Init_11: (+1)
   \       0x7A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??HAL_GPIO_Init_0: (+1)
   \       0x7C   0x2B10             CMP      R3,#+16
   \       0x7E   0xF080 0x80A8      BCS.W    ??HAL_GPIO_Init_12
   \       0x82   0x2501             MOVS     R5,#+1
   \       0x84   0xFA15 0xF203      LSLS     R2,R5,R3
   \       0x88   0x680C             LDR      R4,[R1, #+0]
   \       0x8A   0x4014             ANDS     R4,R2,R4
   \       0x8C   0x4294             CMP      R4,R2
   \       0x8E   0xD1F4             BNE.N    ??HAL_GPIO_Init_11
   \       0x90   0x790A             LDRB     R2,[R1, #+4]
   \       0x92   0xF012 0x0203      ANDS     R2,R2,#0x3
   \       0x96   0x2A01             CMP      R2,#+1
   \       0x98   0xD004             BEQ.N    ??HAL_GPIO_Init_13
   \       0x9A   0x790A             LDRB     R2,[R1, #+4]
   \       0x9C   0xF012 0x0203      ANDS     R2,R2,#0x3
   \       0xA0   0x2A02             CMP      R2,#+2
   \       0xA2   0xD116             BNE.N    ??HAL_GPIO_Init_14
   \                     ??HAL_GPIO_Init_13: (+1)
   \       0xA4   0x6886             LDR      R6,[R0, #+8]
   \       0xA6   0x2703             MOVS     R7,#+3
   \       0xA8   0x001A             MOVS     R2,R3
   \       0xAA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xAC   0x0052             LSLS     R2,R2,#+1
   \       0xAE   0x4097             LSLS     R7,R7,R2
   \       0xB0   0x43BE             BICS     R6,R6,R7
   \       0xB2   0x68CF             LDR      R7,[R1, #+12]
   \       0xB4   0x001A             MOVS     R2,R3
   \       0xB6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xB8   0x0052             LSLS     R2,R2,#+1
   \       0xBA   0x4097             LSLS     R7,R7,R2
   \       0xBC   0x433E             ORRS     R6,R7,R6
   \       0xBE   0x6086             STR      R6,[R0, #+8]
   \       0xC0   0x6842             LDR      R2,[R0, #+4]
   \       0xC2   0x409D             LSLS     R5,R5,R3
   \       0xC4   0x43AA             BICS     R2,R2,R5
   \       0xC6   0x684D             LDR      R5,[R1, #+4]
   \       0xC8   0xF3C5 0x1500      UBFX     R5,R5,#+4,#+1
   \       0xCC   0x409D             LSLS     R5,R5,R3
   \       0xCE   0x432A             ORRS     R2,R5,R2
   \       0xD0   0x6042             STR      R2,[R0, #+4]
   \                     ??HAL_GPIO_Init_14: (+1)
   \       0xD2   0x790A             LDRB     R2,[R1, #+4]
   \       0xD4   0xF012 0x0203      ANDS     R2,R2,#0x3
   \       0xD8   0x2A03             CMP      R2,#+3
   \       0xDA   0xD00D             BEQ.N    ??HAL_GPIO_Init_15
   \       0xDC   0x68C5             LDR      R5,[R0, #+12]
   \       0xDE   0x2603             MOVS     R6,#+3
   \       0xE0   0x001A             MOVS     R2,R3
   \       0xE2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xE4   0x0052             LSLS     R2,R2,#+1
   \       0xE6   0x4096             LSLS     R6,R6,R2
   \       0xE8   0x43B5             BICS     R5,R5,R6
   \       0xEA   0x688E             LDR      R6,[R1, #+8]
   \       0xEC   0x001A             MOVS     R2,R3
   \       0xEE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xF0   0x0052             LSLS     R2,R2,#+1
   \       0xF2   0x4096             LSLS     R6,R6,R2
   \       0xF4   0x4335             ORRS     R5,R6,R5
   \       0xF6   0x60C5             STR      R5,[R0, #+12]
   \                     ??HAL_GPIO_Init_15: (+1)
   \       0xF8   0x790A             LDRB     R2,[R1, #+4]
   \       0xFA   0xF012 0x0203      ANDS     R2,R2,#0x3
   \       0xFE   0x2A02             CMP      R2,#+2
   \      0x100   0xD117             BNE.N    ??HAL_GPIO_Init_16
   \      0x102   0x001A             MOVS     R2,R3
   \      0x104   0x08D2             LSRS     R2,R2,#+3
   \      0x106   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \      0x10A   0x6A15             LDR      R5,[R2, #+32]
   \      0x10C   0x260F             MOVS     R6,#+15
   \      0x10E   0xF013 0x0207      ANDS     R2,R3,#0x7
   \      0x112   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x114   0x0092             LSLS     R2,R2,#+2
   \      0x116   0x4096             LSLS     R6,R6,R2
   \      0x118   0x43B5             BICS     R5,R5,R6
   \      0x11A   0x690E             LDR      R6,[R1, #+16]
   \      0x11C   0xF013 0x0207      ANDS     R2,R3,#0x7
   \      0x120   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x122   0x0092             LSLS     R2,R2,#+2
   \      0x124   0x4096             LSLS     R6,R6,R2
   \      0x126   0x4335             ORRS     R5,R6,R5
   \      0x128   0x001A             MOVS     R2,R3
   \      0x12A   0x08D2             LSRS     R2,R2,#+3
   \      0x12C   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \      0x130   0x6215             STR      R5,[R2, #+32]
   \                     ??HAL_GPIO_Init_16: (+1)
   \      0x132   0x6805             LDR      R5,[R0, #+0]
   \      0x134   0x2603             MOVS     R6,#+3
   \      0x136   0x001A             MOVS     R2,R3
   \      0x138   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x13A   0x0052             LSLS     R2,R2,#+1
   \      0x13C   0x4096             LSLS     R6,R6,R2
   \      0x13E   0x43B5             BICS     R5,R5,R6
   \      0x140   0x790E             LDRB     R6,[R1, #+4]
   \      0x142   0xF016 0x0603      ANDS     R6,R6,#0x3
   \      0x146   0x001A             MOVS     R2,R3
   \      0x148   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x14A   0x0052             LSLS     R2,R2,#+1
   \      0x14C   0x4096             LSLS     R6,R6,R2
   \      0x14E   0x4335             ORRS     R5,R6,R5
   \      0x150   0x6005             STR      R5,[R0, #+0]
   \      0x152   0x684A             LDR      R2,[R1, #+4]
   \      0x154   0xF412 0x3F40      TST      R2,#0x30000
   \      0x158   0xD08F             BEQ.N    ??HAL_GPIO_Init_11
   \      0x15A   0x2200             MOVS     R2,#+0
   \      0x15C   0x9200             STR      R2,[SP, #+0]
   \      0x15E   0x....             LDR.N    R2,??DataTable2_5  ;; 0x40023844
   \      0x160   0x6815             LDR      R5,[R2, #+0]
   \      0x162   0xF455 0x4580      ORRS     R5,R5,#0x4000
   \      0x166   0x6015             STR      R5,[R2, #+0]
   \      0x168   0x6812             LDR      R2,[R2, #+0]
   \      0x16A   0xF412 0x4280      ANDS     R2,R2,#0x4000
   \      0x16E   0x9200             STR      R2,[SP, #+0]
   \      0x170   0x9A00             LDR      R2,[SP, #+0]
   \      0x172   0x....             LDR.N    R5,??DataTable2_6  ;; 0x40013808
   \      0x174   0x001A             MOVS     R2,R3
   \      0x176   0x0892             LSRS     R2,R2,#+2
   \      0x178   0xF855 0x6022      LDR      R6,[R5, R2, LSL #+2]
   \      0x17C   0x270F             MOVS     R7,#+15
   \      0x17E   0xF013 0x0203      ANDS     R2,R3,#0x3
   \      0x182   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x184   0x0092             LSLS     R2,R2,#+2
   \      0x186   0x4097             LSLS     R7,R7,R2
   \      0x188   0x43BE             BICS     R6,R6,R7
   \      0x18A   0x....             LDR.N    R2,??DataTable2_7  ;; 0x40020000
   \      0x18C   0x4290             CMP      R0,R2
   \      0x18E   0xD101             BNE.N    ??HAL_GPIO_Init_17
   \      0x190   0x2700             MOVS     R7,#+0
   \      0x192   0xE742             B.N      ??HAL_GPIO_Init_6
   \                     ??HAL_GPIO_Init_17: (+1)
   \      0x194   0x....             LDR.N    R2,??DataTable2_8  ;; 0x40020400
   \      0x196   0x4290             CMP      R0,R2
   \      0x198   0xD101             BNE.N    ??HAL_GPIO_Init_18
   \      0x19A   0x2701             MOVS     R7,#+1
   \      0x19C   0xE73D             B.N      ??HAL_GPIO_Init_6
   \                     ??HAL_GPIO_Init_18: (+1)
   \      0x19E   0x....             LDR.N    R2,??DataTable2_9  ;; 0x40020800
   \      0x1A0   0x4290             CMP      R0,R2
   \      0x1A2   0xD101             BNE.N    ??HAL_GPIO_Init_19
   \      0x1A4   0x2702             MOVS     R7,#+2
   \      0x1A6   0xE738             B.N      ??HAL_GPIO_Init_5
   \                     ??HAL_GPIO_Init_19: (+1)
   \      0x1A8   0x....             LDR.N    R2,??DataTable2_10  ;; 0x40020c00
   \      0x1AA   0x4290             CMP      R0,R2
   \      0x1AC   0xD101             BNE.N    ??HAL_GPIO_Init_20
   \      0x1AE   0x2703             MOVS     R7,#+3
   \      0x1B0   0xE733             B.N      ??HAL_GPIO_Init_5
   \                     ??HAL_GPIO_Init_20: (+1)
   \      0x1B2   0x....             LDR.N    R2,??DataTable2_11  ;; 0x40021000
   \      0x1B4   0x4290             CMP      R0,R2
   \      0x1B6   0xD101             BNE.N    ??HAL_GPIO_Init_21
   \      0x1B8   0x2704             MOVS     R7,#+4
   \      0x1BA   0xE72E             B.N      ??HAL_GPIO_Init_4
   \                     ??HAL_GPIO_Init_21: (+1)
   \      0x1BC   0x....             LDR.N    R2,??DataTable2_12  ;; 0x40021400
   \      0x1BE   0x4290             CMP      R0,R2
   \      0x1C0   0xD101             BNE.N    ??HAL_GPIO_Init_22
   \      0x1C2   0x2705             MOVS     R7,#+5
   \      0x1C4   0xE729             B.N      ??HAL_GPIO_Init_4
   \                     ??HAL_GPIO_Init_22: (+1)
   \      0x1C6   0x....             LDR.N    R2,??DataTable2_13  ;; 0x40021800
   \      0x1C8   0x4290             CMP      R0,R2
   \      0x1CA   0xF47F 0xAF21      BNE.W    ??HAL_GPIO_Init_3
   \      0x1CE   0x2706             MOVS     R7,#+6
   \      0x1D0   0xE723             B.N      ??HAL_GPIO_Init_2
    281                }
    282              }
    283            }
    284          }
   \                     ??HAL_GPIO_Init_12: (+1)
   \      0x1D2   0xBCF1             POP      {R0,R4-R7}
   \      0x1D4   0x4770             BX       LR               ;; return
    285          
    286          /**
    287            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    288            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    289            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    290            * @param  GPIO_Pin specifies the port bit to be written.
    291            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    292            * @retval None
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    295          {
   \                     HAL_GPIO_DeInit: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    296            uint32_t position;
    297            uint32_t ioposition = 0x00U;
   \        0x2   0x2200             MOVS     R2,#+0
    298            uint32_t iocurrent = 0x00U;
   \        0x4   0x2200             MOVS     R2,#+0
    299            uint32_t tmp = 0x00U;
   \        0x6   0x2200             MOVS     R2,#+0
    300          
    301            /* Check the parameters */
    302            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    303            
    304            /* Configure the port pins */
    305            for(position = 0U; position < GPIO_NUMBER; position++)
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0xE06D             B.N      ??HAL_GPIO_DeInit_0
    306            {
    307              /* Get the IO position */
    308              ioposition = 0x01U << position;
    309              /* Get the current IO position */
    310              iocurrent = (GPIO_Pin) & ioposition;
    311          
    312              if(iocurrent == ioposition)
    313              {
    314                /*------------------------- EXTI Mode Configuration --------------------*/
    315                tmp = SYSCFG->EXTICR[position >> 2U];
    316                tmp &= (0x0FU << (4U * (position & 0x03U)));
    317                if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \        0xC   0xF05F 0x0E08      MOVS     LR,#+8
   \       0x10   0xE004             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \       0x12   0x....             LDR.N    R2,??DataTable2  ;; 0x40021c00
   \       0x14   0x4290             CMP      R0,R2
   \       0x16   0xD1F9             BNE.N    ??HAL_GPIO_DeInit_1
   \       0x18   0xF05F 0x0E07      MOVS     LR,#+7
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \                     ??HAL_GPIO_DeInit_6: (+1)
   \       0x1C   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \       0x20   0xF013 0x0203      ANDS     R2,R3,#0x3
   \       0x24   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x26   0x0092             LSLS     R2,R2,#+2
   \       0x28   0xFA1E 0xFE02      LSLS     LR,LR,R2
   \       0x2C   0x45F4             CMP      R12,LR
   \       0x2E   0xD12A             BNE.N    ??HAL_GPIO_DeInit_7
    318                {
    319                  /* Clear EXTI line configuration */
    320                  EXTI->IMR &= ~((uint32_t)iocurrent);
   \       0x30   0x....             LDR.N    R2,??DataTable2_4  ;; 0x40013c00
   \       0x32   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \       0x36   0xEA3C 0x0C06      BICS     R12,R12,R6
   \       0x3A   0xF8C2 0xC000      STR      R12,[R2, #+0]
    321                  EXTI->EMR &= ~((uint32_t)iocurrent);
   \       0x3E   0x....             LDR.N    R2,??DataTable2_3  ;; 0x40013c04
   \       0x40   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \       0x44   0xEA3C 0x0C06      BICS     R12,R12,R6
   \       0x48   0xF8C2 0xC000      STR      R12,[R2, #+0]
    322                  
    323                  /* Clear Rising Falling edge configuration */
    324                  EXTI->FTSR &= ~((uint32_t)iocurrent);
   \       0x4C   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40013c0c
   \       0x4E   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \       0x52   0xEA3C 0x0C06      BICS     R12,R12,R6
   \       0x56   0xF8C2 0xC000      STR      R12,[R2, #+0]
    325                  EXTI->RTSR &= ~((uint32_t)iocurrent);
   \       0x5A   0x....             LDR.N    R2,??DataTable2_1  ;; 0x40013c08
   \       0x5C   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \       0x60   0xEA3C 0x0606      BICS     R6,R12,R6
   \       0x64   0x6016             STR      R6,[R2, #+0]
    326          
    327                  /* Configure the External Interrupt or event for the current IO */
    328                  tmp = 0x0FU << (4U * (position & 0x03U));
   \       0x66   0xF013 0x0203      ANDS     R2,R3,#0x3
   \       0x6A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x6C   0x0092             LSLS     R2,R2,#+2
   \       0x6E   0xFA15 0xF202      LSLS     R2,R5,R2
    329                  SYSCFG->EXTICR[position >> 2U] &= ~tmp;
   \       0x72   0x001E             MOVS     R6,R3
   \       0x74   0x08B6             LSRS     R6,R6,#+2
   \       0x76   0xF857 0x6026      LDR      R6,[R7, R6, LSL #+2]
   \       0x7A   0xEA36 0x0202      BICS     R2,R6,R2
   \       0x7E   0x001E             MOVS     R6,R3
   \       0x80   0x08B6             LSRS     R6,R6,#+2
   \       0x82   0xF847 0x2026      STR      R2,[R7, R6, LSL #+2]
    330                }
    331          
    332                /*------------------------- GPIO Mode Configuration --------------------*/
    333                /* Configure IO Direction in Input Floating Mode */
    334                GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
   \                     ??HAL_GPIO_DeInit_7: (+1)
   \       0x86   0x2603             MOVS     R6,#+3
   \       0x88   0x6802             LDR      R2,[R0, #+0]
   \       0x8A   0x001F             MOVS     R7,R3
   \       0x8C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x8E   0x007F             LSLS     R7,R7,#+1
   \       0x90   0xFA16 0xF707      LSLS     R7,R6,R7
   \       0x94   0x43BA             BICS     R2,R2,R7
   \       0x96   0x6002             STR      R2,[R0, #+0]
    335          
    336                /* Configure the default Alternate Function in current IO */
    337                GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
   \       0x98   0x001A             MOVS     R2,R3
   \       0x9A   0x08D2             LSRS     R2,R2,#+3
   \       0x9C   0xEB00 0x0782      ADD      R7,R0,R2, LSL #+2
   \       0xA0   0x001A             MOVS     R2,R3
   \       0xA2   0x08D2             LSRS     R2,R2,#+3
   \       0xA4   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \       0xA8   0xF8D2 0xC020      LDR      R12,[R2, #+32]
   \       0xAC   0xF013 0x0207      ANDS     R2,R3,#0x7
   \       0xB0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xB2   0x0092             LSLS     R2,R2,#+2
   \       0xB4   0x4095             LSLS     R5,R5,R2
   \       0xB6   0xEA3C 0x0505      BICS     R5,R12,R5
   \       0xBA   0x623D             STR      R5,[R7, #+32]
    338          
    339                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    340                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
   \       0xBC   0x68C2             LDR      R2,[R0, #+12]
   \       0xBE   0x001D             MOVS     R5,R3
   \       0xC0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \       0xC2   0x006D             LSLS     R5,R5,#+1
   \       0xC4   0xFA16 0xF505      LSLS     R5,R6,R5
   \       0xC8   0x43AA             BICS     R2,R2,R5
   \       0xCA   0x60C2             STR      R2,[R0, #+12]
    341          
    342                /* Configure the default value IO Output Type */
    343                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
   \       0xCC   0x6842             LDR      R2,[R0, #+4]
   \       0xCE   0x409C             LSLS     R4,R4,R3
   \       0xD0   0xEA32 0x0404      BICS     R4,R2,R4
   \       0xD4   0x6044             STR      R4,[R0, #+4]
    344          
    345                /* Configure the default value for IO Speed */
    346                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
   \       0xD6   0x6884             LDR      R4,[R0, #+8]
   \       0xD8   0x001A             MOVS     R2,R3
   \       0xDA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xDC   0x0052             LSLS     R2,R2,#+1
   \       0xDE   0x4096             LSLS     R6,R6,R2
   \       0xE0   0xEA34 0x0606      BICS     R6,R4,R6
   \       0xE4   0x6086             STR      R6,[R0, #+8]
   \                     ??HAL_GPIO_DeInit_8: (+1)
   \       0xE6   0x1C5B             ADDS     R3,R3,#+1
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \       0xE8   0x2B10             CMP      R3,#+16
   \       0xEA   0xD23F             BCS.N    ??HAL_GPIO_DeInit_9
   \       0xEC   0x2401             MOVS     R4,#+1
   \       0xEE   0xFA14 0xF203      LSLS     R2,R4,R3
   \       0xF2   0xEA12 0x0601      ANDS     R6,R2,R1
   \       0xF6   0x4296             CMP      R6,R2
   \       0xF8   0xD1F5             BNE.N    ??HAL_GPIO_DeInit_8
   \       0xFA   0x....             LDR.N    R7,??DataTable2_6  ;; 0x40013808
   \       0xFC   0x001A             MOVS     R2,R3
   \       0xFE   0x0892             LSRS     R2,R2,#+2
   \      0x100   0xF857 0xC022      LDR      R12,[R7, R2, LSL #+2]
   \      0x104   0x250F             MOVS     R5,#+15
   \      0x106   0xF013 0x0203      ANDS     R2,R3,#0x3
   \      0x10A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x10C   0x0092             LSLS     R2,R2,#+2
   \      0x10E   0xFA15 0xF202      LSLS     R2,R5,R2
   \      0x112   0xEA12 0x0C0C      ANDS     R12,R2,R12
   \      0x116   0x....             LDR.N    R2,??DataTable2_7  ;; 0x40020000
   \      0x118   0x4290             CMP      R0,R2
   \      0x11A   0xD102             BNE.N    ??HAL_GPIO_DeInit_10
   \      0x11C   0xF05F 0x0E00      MOVS     LR,#+0
   \      0x120   0xE77C             B.N      ??HAL_GPIO_DeInit_6
   \                     ??HAL_GPIO_DeInit_10: (+1)
   \      0x122   0x....             LDR.N    R2,??DataTable2_8  ;; 0x40020400
   \      0x124   0x4290             CMP      R0,R2
   \      0x126   0xD102             BNE.N    ??HAL_GPIO_DeInit_11
   \      0x128   0xF05F 0x0E01      MOVS     LR,#+1
   \      0x12C   0xE776             B.N      ??HAL_GPIO_DeInit_6
   \                     ??HAL_GPIO_DeInit_11: (+1)
   \      0x12E   0x....             LDR.N    R2,??DataTable2_9  ;; 0x40020800
   \      0x130   0x4290             CMP      R0,R2
   \      0x132   0xD102             BNE.N    ??HAL_GPIO_DeInit_12
   \      0x134   0xF05F 0x0E02      MOVS     LR,#+2
   \      0x138   0xE770             B.N      ??HAL_GPIO_DeInit_5
   \                     ??HAL_GPIO_DeInit_12: (+1)
   \      0x13A   0x....             LDR.N    R2,??DataTable2_10  ;; 0x40020c00
   \      0x13C   0x4290             CMP      R0,R2
   \      0x13E   0xD102             BNE.N    ??HAL_GPIO_DeInit_13
   \      0x140   0xF05F 0x0E03      MOVS     LR,#+3
   \      0x144   0xE76A             B.N      ??HAL_GPIO_DeInit_5
   \                     ??HAL_GPIO_DeInit_13: (+1)
   \      0x146   0x....             LDR.N    R2,??DataTable2_11  ;; 0x40021000
   \      0x148   0x4290             CMP      R0,R2
   \      0x14A   0xD102             BNE.N    ??HAL_GPIO_DeInit_14
   \      0x14C   0xF05F 0x0E04      MOVS     LR,#+4
   \      0x150   0xE764             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_14: (+1)
   \      0x152   0x....             LDR.N    R2,??DataTable2_12  ;; 0x40021400
   \      0x154   0x4290             CMP      R0,R2
   \      0x156   0xD102             BNE.N    ??HAL_GPIO_DeInit_15
   \      0x158   0xF05F 0x0E05      MOVS     LR,#+5
   \      0x15C   0xE75E             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_15: (+1)
   \      0x15E   0x....             LDR.N    R2,??DataTable2_13  ;; 0x40021800
   \      0x160   0x4290             CMP      R0,R2
   \      0x162   0xF47F 0xAF56      BNE.W    ??HAL_GPIO_DeInit_3
   \      0x166   0xF05F 0x0E06      MOVS     LR,#+6
   \      0x16A   0xE757             B.N      ??HAL_GPIO_DeInit_2
    347              }
    348            }
    349          }
   \                     ??HAL_GPIO_DeInit_9: (+1)
   \      0x16C   0xBDF0             POP      {R4-R7,PC}       ;; return
    350          
    351          /**
    352            * @}
    353            */
    354          
    355          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions 
    356            *  @brief   GPIO Read and Write
    357            *
    358          @verbatim
    359           ===============================================================================
    360                                 ##### IO operation functions #####
    361           ===============================================================================
    362          
    363          @endverbatim
    364            * @{
    365            */
    366          
    367          /**
    368            * @brief  Reads the specified input port pin.
    369            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    370            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    371            * @param  GPIO_Pin specifies the port bit to read.
    372            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    373            * @retval The input port pin value.
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    376          {
    377            GPIO_PinState bitstatus;
    378          
    379            /* Check the parameters */
    380            assert_param(IS_GPIO_PIN(GPIO_Pin));
    381          
    382            if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \                     HAL_GPIO_ReadPin: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0x4   0x4208             TST      R0,R1
   \        0x6   0xD001             BEQ.N    ??HAL_GPIO_ReadPin_0
    383            {
    384              bitstatus = GPIO_PIN_SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??HAL_GPIO_ReadPin_1
    385            }
    386            else
    387            {
    388              bitstatus = GPIO_PIN_RESET;
   \                     ??HAL_GPIO_ReadPin_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
    389            }
    390            return bitstatus;
   \                     ??HAL_GPIO_ReadPin_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x10   0x4770             BX       LR               ;; return
    391          }
    392          
    393          /**
    394            * @brief  Sets or clears the selected data port bit.
    395            *
    396            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
    397            *         accesses. In this way, there is no risk of an IRQ occurring between
    398            *         the read and the modify access.
    399            *
    400            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    401            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    402            * @param  GPIO_Pin specifies the port bit to be written.
    403            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    404            * @param  PinState specifies the value to be written to the selected bit.
    405            *          This parameter can be one of the GPIO_PinState enum values:
    406            *            @arg GPIO_PIN_RESET: to clear the port pin
    407            *            @arg GPIO_PIN_SET: to set the port pin
    408            * @retval None
    409            */

   \                                 In section .text, align 2, keep-with-next
    410          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    411          {
    412            /* Check the parameters */
    413            assert_param(IS_GPIO_PIN(GPIO_Pin));
    414            assert_param(IS_GPIO_PIN_ACTION(PinState));
    415          
    416            if(PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD002             BEQ.N    ??HAL_GPIO_WritePin_0
    417            {
    418              GPIOx->BSRR = GPIO_Pin;
   \        0x6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0x8   0x6181             STR      R1,[R0, #+24]
   \        0xA   0xE002             B.N      ??HAL_GPIO_WritePin_1
    419            }
    420            else
    421            {
    422              GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \        0xC   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0xE   0x0409             LSLS     R1,R1,#+16
   \       0x10   0x6181             STR      R1,[R0, #+24]
    423            }
    424          }
   \                     ??HAL_GPIO_WritePin_1: (+1)
   \       0x12   0x4770             BX       LR               ;; return
    425          
    426          /**
    427            * @brief  Toggles the specified GPIO pins.
    428            * @param  GPIOx Where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    429            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    430            * @param  GPIO_Pin Specifies the pins to be toggled.
    431            * @retval None
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    434          {
    435            uint32_t odr;
    436          
    437            /* Check the parameters */
    438            assert_param(IS_GPIO_PIN(GPIO_Pin));
    439          
    440            /* get current Output Data Register value */
    441            odr = GPIOx->ODR;
   \                     HAL_GPIO_TogglePin: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
    442          
    443            /* Set selected pins that were at low level, and reset ones that were high */
    444            GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
   \        0x2   0x000B             MOVS     R3,R1
   \        0x4   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0xA   0x4391             BICS     R1,R1,R2
   \        0xC   0xEA51 0x4103      ORRS     R1,R1,R3, LSL #+16
   \       0x10   0x6181             STR      R1,[R0, #+24]
    445          }
   \       0x12   0x4770             BX       LR               ;; return
    446          
    447          /**
    448            * @brief  Locks GPIO Pins configuration registers.
    449            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    450            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    451            * @note   The configuration of the locked GPIO pins can no longer be modified
    452            *         until the next reset.
    453            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F4 family
    454            * @param  GPIO_Pin specifies the port bit to be locked.
    455            *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
    456            * @retval None
    457            */

   \                                 In section .text, align 2, keep-with-next
    458          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    459          {
   \                     HAL_GPIO_LockPin: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    460            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \        0x2   0xF45F 0x3280      MOVS     R2,#+65536
   \        0x6   0x9200             STR      R2,[SP, #+0]
    461          
    462            /* Check the parameters */
    463            assert_param(IS_GPIO_PIN(GPIO_Pin));
    464          
    465            /* Apply lock key write sequence */
    466            tmp |= GPIO_Pin;
   \        0x8   0x9B00             LDR      R3,[SP, #+0]
   \        0xA   0x000A             MOVS     R2,R1
   \        0xC   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \        0xE   0x4313             ORRS     R3,R2,R3
   \       0x10   0x9300             STR      R3,[SP, #+0]
    467            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    468            GPIOx->LCKR = tmp;
   \       0x12   0x9A00             LDR      R2,[SP, #+0]
   \       0x14   0x61C2             STR      R2,[R0, #+28]
    469            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    470            GPIOx->LCKR = GPIO_Pin;
   \       0x16   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x18   0x61C1             STR      R1,[R0, #+28]
    471            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    472            GPIOx->LCKR = tmp;
   \       0x1A   0x9900             LDR      R1,[SP, #+0]
   \       0x1C   0x61C1             STR      R1,[R0, #+28]
    473            /* Read LCKR register. This read is mandatory to complete key lock sequence */
    474            tmp = GPIOx->LCKR;
   \       0x1E   0x69C1             LDR      R1,[R0, #+28]
   \       0x20   0x9100             STR      R1,[SP, #+0]
    475          
    476            /* Read again in order to confirm lock is active */
    477           if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
   \       0x22   0x69C0             LDR      R0,[R0, #+28]
   \       0x24   0x03C0             LSLS     R0,R0,#+15
   \       0x26   0xD501             BPL.N    ??HAL_GPIO_LockPin_0
    478            {
    479              return HAL_OK;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE000             B.N      ??HAL_GPIO_LockPin_1
    480            }
    481            else
    482            {
    483              return HAL_ERROR;
   \                     ??HAL_GPIO_LockPin_0: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \                     ??HAL_GPIO_LockPin_1: (+1)
   \       0x2E   0xB001             ADD      SP,SP,#+4
   \       0x30   0x4770             BX       LR               ;; return
    484            }
    485          }
    486          
    487          /**
    488            * @brief  This function handles EXTI interrupt request.
    489            * @param  GPIO_Pin Specifies the pins connected EXTI line
    490            * @retval None
    491            */

   \                                 In section .text, align 2, keep-with-next
    492          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    493          {
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    494            /* EXTI line interrupt detected */
    495            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
   \        0x2   0x....             LDR.N    R1,??DataTable2_14  ;; 0x40013c14
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x0003             MOVS     R3,R0
   \        0x8   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \        0xA   0x421A             TST      R2,R3
   \        0xC   0xD005             BEQ.N    ??HAL_GPIO_EXTI_IRQHandler_0
    496            {
    497              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \        0xE   0x0002             MOVS     R2,R0
   \       0x10   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \       0x12   0x600A             STR      R2,[R1, #+0]
    498              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \       0x14   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x16   0x....'....        BL       HAL_GPIO_EXTI_Callback
    499            }
    500          }
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
    501          
    502          /**
    503            * @brief  EXTI line detection callbacks.
    504            * @param  GPIO_Pin Specifies the pins connected EXTI line
    505            * @retval None
    506            */

   \                                 In section .text, align 2
    507          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    508          {
    509            /* Prevent unused argument(s) compilation warning */
    510            UNUSED(GPIO_Pin);
    511            /* NOTE: This function Should not be modified, when the callback is needed,
    512                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    513             */
    514          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x4002'1C00        DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x4001'3C08        DC32     0x40013c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x4001'3C0C        DC32     0x40013c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4001'3C04        DC32     0x40013c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x4001'3C00        DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x4002'3844        DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x4001'3808        DC32     0x40013808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0x4002'0400        DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0x4002'0800        DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \        0x0   0x4002'0C00        DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \        0x0   0x4002'1400        DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \        0x0   0x4002'1800        DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \        0x0   0x4001'3C14        DC32     0x40013c14
    515          
    516          /**
    517            * @}
    518            */
    519          
    520          
    521          /**
    522            * @}
    523            */
    524          
    525          #endif /* HAL_GPIO_MODULE_ENABLED */
    526          /**
    527            * @}
    528            */
    529          
    530          /**
    531            * @}
    532            */
    533          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Callback
      20   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     366  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      28  HAL_GPIO_EXTI_IRQHandler
     470  HAL_GPIO_Init
      50  HAL_GPIO_LockPin
      18  HAL_GPIO_ReadPin
      20  HAL_GPIO_TogglePin
      20  HAL_GPIO_WritePin

 
 1 034 bytes in section .text
 
 1 032 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
